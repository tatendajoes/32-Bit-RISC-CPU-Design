$date
   Tue Aug 26 02:47:06 2025
$end
$version
  2020.1
$end
$timescale
  1ps
$end
$scope module cpu_branch_tb $end
$var reg 1 ! clk $end
$var reg 1 " rst_n $end
$var wire 32 # pc [31:0] $end
$var wire 32 $ instr [31:0] $end
$var wire 1 % mem_read $end
$var wire 1 & mem_write $end
$var wire 32 ' mem_addr [31:0] $end
$var wire 32 ( mem_wdata [31:0] $end
$var wire 32 ) mem_rdata [31:0] $end
$var reg 32 * prev_pc [31:0] $end
$scope module uut $end
$var wire 1 + clk $end
$var wire 1 , rst_n $end
$var wire 32 # pc [31:0] $end
$var wire 32 $ instr [31:0] $end
$var wire 1 % mem_read $end
$var wire 1 & mem_write $end
$var wire 32 ' mem_addr [31:0] $end
$var wire 32 ( mem_wdata [31:0] $end
$var wire 32 ) mem_rdata [31:0] $end
$var wire 32 - next_pc [31:0] $end
$var wire 32 . pc_plus4 [31:0] $end
$var wire 1 / reg_write $end
$var wire 1 0 alu_src $end
$var wire 1 1 mem_to_reg $end
$var wire 1 2 branch $end
$var wire 3 3 alu_op [2:0] $end
$var wire 32 4 rs1_data [31:0] $end
$var wire 32 5 rs2_data [31:0] $end
$var wire 32 6 alu_result [31:0] $end
$var wire 1 7 zero_flag $end
$var wire 32 8 imm_i [31:0] $end
$var wire 32 9 imm_s [31:0] $end
$var wire 32 : imm_b [31:0] $end
$var wire 32 ; imm [31:0] $end
$var wire 32 < alu_in2 [31:0] $end
$var wire 32 = branch_target [31:0] $end
$scope module pc_inst $end
$var wire 1 + clk $end
$var wire 1 , rst $end
$var wire 32 - next_pc [31:0] $end
$var reg 32 > pc [31:0] $end
$upscope $end
$scope module imem $end
$var wire 32 # addr [31:0] $end
$var reg 32 ? instruction [31:0] $end
$scope begin Block11_2 $end
$var integer 32 @ i $end
$upscope $end
$upscope $end
$scope module cu $end
$var wire 7 A opcode [6:0] $end
$var wire 3 B funct3 [2:0] $end
$var wire 1 C funct7_5 $end
$var reg 1 D reg_write $end
$var reg 1 E alu_src $end
$var reg 1 F mem_read $end
$var reg 1 G mem_write $end
$var reg 1 H mem_to_reg $end
$var reg 1 I branch $end
$var reg 3 J alu_op [2:0] $end
$var parameter 3 K ALU_ADD [2:0] $end
$var parameter 3 L ALU_SUB [2:0] $end
$var parameter 3 M ALU_AND [2:0] $end
$var parameter 3 N ALU_OR [2:0] $end
$var parameter 3 O ALU_SLT [2:0] $end
$var parameter 7 P OPC_RTYPE [6:0] $end
$var parameter 7 Q OPC_LW [6:0] $end
$var parameter 7 R OPC_SW [6:0] $end
$var parameter 7 S OPC_BEQ [6:0] $end
$upscope $end
$scope module rf $end
$var wire 1 + clk $end
$var wire 1 / we $end
$var wire 5 T rd [4:0] $end
$var wire 32 U wd [31:0] $end
$var wire 5 V rs1 [4:0] $end
$var wire 5 W rs2 [4:0] $end
$var wire 32 4 rd1 [31:0] $end
$var wire 32 5 rd2 [31:0] $end
$var integer 32 X i $end
$upscope $end
$scope module arithmetic_unit $end
$var wire 32 4 a [31:0] $end
$var wire 32 < b [31:0] $end
$var wire 3 3 alu_op [2:0] $end
$var reg 32 Y result [31:0] $end
$var wire 1 7 zero $end
$var parameter 3 Z ALU_ADD [2:0] $end
$var parameter 3 [ ALU_SUB [2:0] $end
$var parameter 3 \ ALU_AND [2:0] $end
$var parameter 3 ] ALU_OR [2:0] $end
$var parameter 3 ^ ALU_SLT [2:0] $end
$upscope $end
$upscope $end
$scope module dm $end
$var wire 1 _ clk $end
$var wire 1 % mem_read $end
$var wire 1 & mem_write $end
$var wire 32 ' addr [31:0] $end
$var wire 32 ( write_data [31:0] $end
$var wire 32 ) read_data [31:0] $end
$var integer 32 ` i $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
1!
1"
b10100100 #
b10011 $
0%
0&
b0 '
b0 (
b0 )
b10100000 *
1+
1,
b10101000 -
b10101000 .
0/
00
01
02
b0 3
b0 4
b0 5
b0 6
17
b0 8
b0 9
b0 :
b0 ;
b0 <
b10100100 =
b10100100 >
b10011 ?
b100000000 @
b10011 A
b0 B
0C
0D
0E
0F
0G
0H
0I
b0 J
b0 K
b1 L
b10 M
b11 N
b100 O
b110011 P
b11 Q
b100011 R
b1100011 S
b0 T
b0 U
b0 V
b0 W
b100000 X
b0 Y
b0 Z
b1 [
b10 \
b11 ]
b100 ^
1_
b100000000 `
$end
