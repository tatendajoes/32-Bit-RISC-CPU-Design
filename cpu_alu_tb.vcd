$date
   Tue Aug 26 02:45:18 2025
$end
$version
  2020.1
$end
$timescale
  1ps
$end
$scope module cpu_alu_tb $end
$var reg 1 ! clk $end
$var reg 1 " rst_n $end
$var wire 32 # pc [31:0] $end
$var wire 32 $ instr [31:0] $end
$var wire 1 % mem_read $end
$var wire 1 & mem_write $end
$var wire 32 ' mem_addr [31:0] $end
$var wire 32 ( mem_wdata [31:0] $end
$var wire 32 ) mem_rdata [31:0] $end
$scope module uut $end
$var wire 1 * clk $end
$var wire 1 + rst_n $end
$var wire 32 # pc [31:0] $end
$var wire 32 $ instr [31:0] $end
$var wire 1 % mem_read $end
$var wire 1 & mem_write $end
$var wire 32 ' mem_addr [31:0] $end
$var wire 32 ( mem_wdata [31:0] $end
$var wire 32 ) mem_rdata [31:0] $end
$var wire 32 , next_pc [31:0] $end
$var wire 32 - pc_plus4 [31:0] $end
$var wire 1 . reg_write $end
$var wire 1 / alu_src $end
$var wire 1 0 mem_to_reg $end
$var wire 1 1 branch $end
$var wire 3 2 alu_op [2:0] $end
$var wire 32 3 rs1_data [31:0] $end
$var wire 32 4 rs2_data [31:0] $end
$var wire 32 5 alu_result [31:0] $end
$var wire 1 6 zero_flag $end
$var wire 32 7 imm_i [31:0] $end
$var wire 32 8 imm_s [31:0] $end
$var wire 32 9 imm_b [31:0] $end
$var wire 32 : imm [31:0] $end
$var wire 32 ; alu_in2 [31:0] $end
$var wire 32 < branch_target [31:0] $end
$scope module pc_inst $end
$var wire 1 * clk $end
$var wire 1 + rst $end
$var wire 32 , next_pc [31:0] $end
$var reg 32 = pc [31:0] $end
$upscope $end
$scope module imem $end
$var wire 32 # addr [31:0] $end
$var reg 32 > instruction [31:0] $end
$scope begin Block11_2 $end
$var integer 32 ? i $end
$upscope $end
$upscope $end
$scope module cu $end
$var wire 7 @ opcode [6:0] $end
$var wire 3 A funct3 [2:0] $end
$var wire 1 B funct7_5 $end
$var reg 1 C reg_write $end
$var reg 1 D alu_src $end
$var reg 1 E mem_read $end
$var reg 1 F mem_write $end
$var reg 1 G mem_to_reg $end
$var reg 1 H branch $end
$var reg 3 I alu_op [2:0] $end
$var parameter 3 J ALU_ADD [2:0] $end
$var parameter 3 K ALU_SUB [2:0] $end
$var parameter 3 L ALU_AND [2:0] $end
$var parameter 3 M ALU_OR [2:0] $end
$var parameter 3 N ALU_SLT [2:0] $end
$var parameter 7 O OPC_RTYPE [6:0] $end
$var parameter 7 P OPC_LW [6:0] $end
$var parameter 7 Q OPC_SW [6:0] $end
$var parameter 7 R OPC_BEQ [6:0] $end
$upscope $end
$scope module rf $end
$var wire 1 * clk $end
$var wire 1 . we $end
$var wire 5 S rd [4:0] $end
$var wire 32 T wd [31:0] $end
$var wire 5 U rs1 [4:0] $end
$var wire 5 V rs2 [4:0] $end
$var wire 32 3 rd1 [31:0] $end
$var wire 32 4 rd2 [31:0] $end
$var integer 32 W i $end
$upscope $end
$scope module arithmetic_unit $end
$var wire 32 3 a [31:0] $end
$var wire 32 ; b [31:0] $end
$var wire 3 2 alu_op [2:0] $end
$var reg 32 X result [31:0] $end
$var wire 1 6 zero $end
$var parameter 3 Y ALU_ADD [2:0] $end
$var parameter 3 Z ALU_SUB [2:0] $end
$var parameter 3 [ ALU_AND [2:0] $end
$var parameter 3 \ ALU_OR [2:0] $end
$var parameter 3 ] ALU_SLT [2:0] $end
$upscope $end
$upscope $end
$scope module dm $end
$var wire 1 ^ clk $end
$var wire 1 % mem_read $end
$var wire 1 & mem_write $end
$var wire 32 ' addr [31:0] $end
$var wire 32 ( write_data [31:0] $end
$var wire 32 ) read_data [31:0] $end
$var integer 32 _ i $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
1!
1"
b1111000 #
b10011 $
0%
0&
b0 '
b0 (
b0 )
1*
1+
b1111100 ,
b1111100 -
0.
0/
00
01
b0 2
b0 3
b0 4
b0 5
16
b0 7
b0 8
b0 9
b0 :
b0 ;
b1111000 <
b1111000 =
b10011 >
b100000000 ?
b10011 @
b0 A
0B
0C
0D
0E
0F
0G
0H
b0 I
b0 J
b1 K
b10 L
b11 M
b100 N
b110011 O
b11 P
b100011 Q
b1100011 R
b0 S
b0 T
b0 U
b0 V
b100000 W
b0 X
b0 Y
b1 Z
b10 [
b11 \
b100 ]
1^
b100000000 _
$end
