$date
   Tue Aug 26 02:38:46 2025
$end
$version
  2020.1
$end
$timescale
  1ps
$end
$scope module cpu_tb $end
$var reg 1 ! clk $end
$var reg 1 " rst_n $end
$var wire 32 # pc [31:0] $end
$var wire 32 $ instr [31:0] $end
$var wire 1 % mem_read $end
$var wire 1 & mem_write $end
$var wire 32 ' mem_addr [31:0] $end
$var wire 32 ( mem_wdata [31:0] $end
$var wire 32 ) mem_rdata [31:0] $end
$scope module dut $end
$var wire 1 * clk $end
$var wire 1 + rst_n $end
$var wire 32 # pc [31:0] $end
$var wire 32 $ instr [31:0] $end
$var wire 1 % mem_read $end
$var wire 1 & mem_write $end
$var wire 32 ' mem_addr [31:0] $end
$var wire 32 ( mem_wdata [31:0] $end
$var wire 32 ) mem_rdata [31:0] $end
$var wire 32 , next_pc [31:0] $end
$var wire 32 - pc_plus4 [31:0] $end
$var wire 1 . reg_write $end
$var wire 1 / alu_src $end
$var wire 1 0 mem_to_reg $end
$var wire 1 1 branch $end
$var wire 3 2 alu_op [2:0] $end
$var wire 32 3 rs1_data [31:0] $end
$var wire 32 4 rs2_data [31:0] $end
$var wire 32 5 alu_result [31:0] $end
$var wire 1 6 zero_flag $end
$var wire 32 7 imm_i [31:0] $end
$var wire 32 8 imm_s [31:0] $end
$var wire 32 9 imm_b [31:0] $end
$var wire 32 : imm [31:0] $end
$var wire 32 ; alu_in2 [31:0] $end
$var wire 32 < branch_target [31:0] $end
$scope module pc_inst $end
$var wire 1 * clk $end
$var wire 1 = rst $end
$var wire 32 , next_pc [31:0] $end
$var reg 32 > pc [31:0] $end
$upscope $end
$scope module imem $end
$var wire 32 # addr [31:0] $end
$var reg 32 ? instruction [31:0] $end
$scope begin Block11_3 $end
$var integer 32 @ i $end
$upscope $end
$upscope $end
$scope module cu $end
$var wire 7 A opcode [6:0] $end
$var wire 3 B funct3 [2:0] $end
$var wire 1 C funct7_5 $end
$var reg 1 D reg_write $end
$var reg 1 E alu_src $end
$var reg 1 F mem_read $end
$var reg 1 G mem_write $end
$var reg 1 H mem_to_reg $end
$var reg 1 I branch $end
$var reg 3 J alu_op [2:0] $end
$var parameter 3 K ALU_ADD [2:0] $end
$var parameter 3 L ALU_SUB [2:0] $end
$var parameter 3 M ALU_AND [2:0] $end
$var parameter 3 N ALU_OR [2:0] $end
$var parameter 3 O ALU_SLT [2:0] $end
$var parameter 7 P OPC_RTYPE [6:0] $end
$var parameter 7 Q OPC_LW [6:0] $end
$var parameter 7 R OPC_SW [6:0] $end
$var parameter 7 S OPC_BEQ [6:0] $end
$upscope $end
$scope module rf $end
$var wire 1 * clk $end
$var wire 1 . we $end
$var wire 5 T rd [4:0] $end
$var wire 32 U wd [31:0] $end
$var wire 5 V rs1 [4:0] $end
$var wire 5 W rs2 [4:0] $end
$var wire 32 3 rd1 [31:0] $end
$var wire 32 4 rd2 [31:0] $end
$var integer 32 X i $end
$upscope $end
$scope module arithmetic_unit $end
$var wire 32 3 a [31:0] $end
$var wire 32 ; b [31:0] $end
$var wire 3 2 alu_op [2:0] $end
$var reg 32 Y result [31:0] $end
$var wire 1 6 zero $end
$var parameter 3 Z ALU_ADD [2:0] $end
$var parameter 3 [ ALU_SUB [2:0] $end
$var parameter 3 \ ALU_AND [2:0] $end
$var parameter 3 ] ALU_OR [2:0] $end
$var parameter 3 ^ ALU_SLT [2:0] $end
$upscope $end
$upscope $end
$scope begin Block55_12 $end
$var reg 32 _ i $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
1!
1"
b0 #
b10011 $
0%
0&
b0 '
b0 (
b0 )
1*
1+
b100 ,
b100 -
0.
0/
00
01
b0 2
b0 3
b0 4
b0 5
16
b0 7
b0 8
b0 9
b0 :
b0 ;
b0 <
0=
b0 >
b10011 ?
b100000000 @
b10011 A
b0 B
0C
0D
0E
0F
0G
0H
0I
b0 J
b0 K
b1 L
b10 M
b11 N
b100 O
b110011 P
b11 Q
b100011 R
b1100011 S
b0 T
b0 U
b0 V
b0 W
b100000 X
b0 Y
b0 Z
b1 [
b10 \
b11 ]
b100 ^
b100000000 _
$end
